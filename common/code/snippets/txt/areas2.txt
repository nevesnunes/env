Abundant-data applications, algorithms and architectures are a meta-topic that includes research avenues such as data mining (quickly finding relatively simple patterns in massive amounts of loosely structured data, evaluating and labeling data, etc), machine learning (building mathematical models that represent structure and statistical trends in data, with good predictive properties), hardware architectures to process more data than is possible today.

Artificial intelligence and robotics - broadly, figuring out how to formalize human capabilities which currently appear beyond the reach of computers and robots, then make computers and robots more efficient at it. Self-driving cars and swarms of search-and-rescue robots are a good illustration. In the past, once good model were found for something (such as computer-aided design of electronic circuits), this research moves into a different field - the design of efficient algorithms, statistical models, computing hardware, etc.

Bio-informatics and other uses of CS in biology, biomedical engineering and medicine, including systems biology (modeling interactions of multiple systems in a living organism, including immune systems and cancer development),  computational biophysics (modeling and understanding mechanical, electrical, and molecular-level interactions inside an organism),  computational neurobiology (understanding how organisms process incoming information and react to it, control their bodies, store information, and think). There is a very large gap between what is known about brain structure and the functional capabilities of a living brain - closing this gap is one of the grand challenged in modern science and engineering. DNA analysis and genetics have also become computer-based in the last 20 years. Biomedical engineering is another major area of growth, where microprocessor-based systems can monitor vital signs and even administer life-saving medications without waiting for a doctor. Computer-aided design of prosthetics is very promising.

Computer-assisted education, especially at the high-school level. Even for CS, few high schools offer competent curriculum, even in developped countries. Cheat-proof automated support for exams and testing, essay grading, generation of multiple-choice questions.  Support for learning specific skills, such as programming (immediate feedback on simple mistakes and suggestions on how to fix them, peer grading, style analysis).

Databases, data centers, information retrieval and natural-language processing: collecting and storing massive collections of data and making them easily available (indexing, search), helping computers understand (structure in) human-generated documents and artifacts of all kinds (speech, video, text, motion, biometrics) and helping people search for the information they need when they need it. There are many interactions with abundant-data applications here, as well as with human-computer interaction, as well as with networking.

Emerging technologies for computing hardware, communication and sensing: new models of computation (such as optical and quantum computing) and figuring out what they are [not] good for. Best uses for  three-dimensional integrated circuits and a variety of new memory chips. Modeling and using new types of electronic switches (memristors, devices using carbon nano-tubes, etc), quantum communication and cryptography, and a lot more.

Human-computer interaction covers human-computer interface design and focused techniques that allow computers to understand people (detect emotions, intent, level of skill), as well as the design of human-facing software (social networks) and hardware (talking smart-phones and self-driving cars).

Large-scale networking: high-performance hardware for data centers, mobile networking, support for more efficient multicast, multimedia, and high-level user-facing services (social networks), networking services for developing countries (without permanent high-bandwidth connections), various policy issues (who should run the Internet and whether the governments should control it). Outer-space communication networks. Network security (which I also listed under Security) is also a big deal.

Limits of computation and communication at the level of problem types (some problems cannot be solved in principle!), algorithms (sometimes an efficient algorithm is unlikely to exist) and physical resources, especially space, time, energy and materials. This topic covers Complexity Theory from Theoretical CS, but also the practical obstacles faced by the designers of modern electronic systems, hinting at limits that have not yet been formalized.

Multimedia: graphics, audio (speech, music, ambient sound), video - analysis, compression, generation, playback, multi-channel communication etc. Both hardware and software are involved. Specific questions include scene analysis (describing what's on the picture), comprehending movement, synthesizing realistic multimedia, etc.

Programming languages and environments: automated analysis of programs in terms of correctness and resource requirements, comparisons between languages, software support for languages (i.e., compilation), program optimization, support for parallel programming, domain-specific languages, interactions between languages, systems that assist programmers by inferring their intent.

Security of computer systems and support for digital democracy, including network-level security (intrusion detection and defense), OS-level security (anti-virus SW) and physical security (biometrics, tamper-proof packaging, trusted computing on untrusted platforms), support for personal privacy (efficient and user-friendly encryption), free speech (file sharing, circumventing sensors and network restrictions by oppressive regimes), as well as issues related to electronic polls and voting. Security is also a major issue in the use of embedded systems and the Internet of Things (IoT).

Verification, proofs, and automated debugging of hardware designs, software, networking protocols, mathematical theorems, etc. This includes formal reasoning (proof systems and new types of logical arguments), finding bugs efficiently and diagnosing them, finding bug fixes, and confirming the absence of bugs (usually by means of automated theorem-proving).
